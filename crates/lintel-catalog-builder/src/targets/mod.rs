mod dir;
mod github_pages;

use core::fmt::Write as _;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use schema_catalog::{Catalog, SchemaEntry};
use tracing::debug;

use crate::catalog::write_catalog_json;
use lintel_catalog_builder::config::TargetConfig;

pub use self::dir::DirTarget;
pub use self::github_pages::GitHubPagesTarget;

/// Data passed to [`Target::finalize`] for writing output files.
pub struct OutputContext<'a> {
    pub output_dir: &'a Path,
    pub config_path: &'a Path,
    pub catalog: &'a Catalog,
    pub groups_meta: &'a [(String, String)],
    pub source_count: usize,
}

/// Behaviour that every output target must implement.
pub trait Target {
    /// The `base_url` configured for this target.
    fn base_url(&self) -> &str;

    /// Resolve the output directory for this target.
    fn output_dir(&self, target_name: &str, config_dir: &Path) -> PathBuf;

    /// Write all output files for this target.
    fn finalize(
        &self,
        ctx: &OutputContext<'_>,
    ) -> impl core::future::Future<Output = Result<()>> + Send;
}

/// Enum dispatch wrapper so we can store any target without `dyn`.
pub enum AnyTarget {
    Dir(DirTarget),
    GitHubPages(GitHubPagesTarget),
}

impl From<TargetConfig> for AnyTarget {
    fn from(config: TargetConfig) -> Self {
        match config {
            TargetConfig::Dir {
                dir,
                base_url,
                github,
            } => Self::Dir(DirTarget {
                dir,
                base_url,
                github,
            }),
            TargetConfig::GitHubPages {
                base_url,
                cname,
                dir,
            } => Self::GitHubPages(GitHubPagesTarget {
                base_url,
                cname,
                dir,
            }),
        }
    }
}

impl Target for AnyTarget {
    fn base_url(&self) -> &str {
        match self {
            Self::Dir(t) => t.base_url(),
            Self::GitHubPages(t) => t.base_url(),
        }
    }

    fn output_dir(&self, target_name: &str, config_dir: &Path) -> PathBuf {
        match self {
            Self::Dir(t) => t.output_dir(target_name, config_dir),
            Self::GitHubPages(t) => t.output_dir(target_name, config_dir),
        }
    }

    async fn finalize(&self, ctx: &OutputContext<'_>) -> Result<()> {
        match self {
            Self::Dir(t) => t.finalize(ctx).await,
            Self::GitHubPages(t) => t.finalize(ctx).await,
        }
    }
}

/// Write `catalog.json`, `README.md`, and `index.html` — shared by all targets.
pub async fn write_common_files(ctx: &OutputContext<'_>) -> Result<()> {
    write_catalog_json(ctx.output_dir, ctx.catalog).await?;
    write_readme(ctx).await?;
    write_index_html(ctx).await?;
    Ok(())
}

/// Generate and write `index.html` in the output directory.
async fn write_index_html(ctx: &OutputContext<'_>) -> Result<()> {
    let html = generate_index_html(ctx.catalog, ctx.groups_meta);
    let path = ctx.output_dir.join("index.html");
    tokio::fs::write(&path, html)
        .await
        .with_context(|| format!("failed to write {}", path.display()))?;
    debug!(path = %path.display(), "wrote index.html");
    Ok(())
}

/// Generate a `README.md` in the output directory.
async fn write_readme(ctx: &OutputContext<'_>) -> Result<()> {
    let config_dir = ctx.config_path.parent().unwrap_or_else(|| Path::new("."));
    let source_repo = detect_git_remote(config_dir).await;
    let config_filename = ctx
        .config_path
        .file_name()
        .unwrap_or_default()
        .to_string_lossy();

    let schema_count = ctx.catalog.schemas.len();
    let group_count = ctx.catalog.groups.len();
    let source_count = ctx.source_count;

    let mut md = String::new();
    md.push_str("# Schema Catalog\n\n");
    md.push_str("This directory was generated by [`lintel-catalog-builder`](https://github.com/lintel-rs/lintel).\n");
    md.push_str("**Do not edit files in this directory manually** — they will be overwritten on the next run.\n\n");

    if let Some(ref repo_url) = source_repo {
        let _ = write!(md, "Source repository: <{repo_url}>\n\n");
    }

    md.push_str("## Stats\n\n");
    let _ = writeln!(md, "- **{schema_count}** schemas");
    let _ = writeln!(md, "- **{group_count}** groups");
    let _ = writeln!(md, "- **{source_count}** external sources\n");

    md.push_str("## Regenerate\n\n");
    md.push_str("```sh\n");
    let _ = writeln!(
        md,
        "lintel-catalog-builder generate --config {config_filename}"
    );
    md.push_str("```\n");

    let readme_path = ctx.output_dir.join("README.md");
    tokio::fs::write(&readme_path, md)
        .await
        .with_context(|| format!("failed to write {}", readme_path.display()))?;
    debug!(path = %readme_path.display(), "wrote README.md");
    Ok(())
}

/// Try to detect the git remote URL for a directory.
async fn detect_git_remote(dir: &Path) -> Option<String> {
    let output = tokio::process::Command::new("git")
        .args(["-C", &dir.to_string_lossy(), "remote", "get-url", "origin"])
        .output()
        .await
        .ok()?;
    if !output.status.success() {
        return None;
    }
    let url = core::str::from_utf8(&output.stdout)
        .ok()?
        .trim()
        .to_string();
    if url.is_empty() {
        return None;
    }
    Some(url)
}

/// Generate a self-contained `index.html` landing page for the catalog.
#[allow(clippy::too_many_lines)]
fn generate_index_html(catalog: &Catalog, groups_meta: &[(String, String)]) -> String {
    let mut html = String::new();
    html.push_str(INDEX_HTML_HEAD);

    // Stats
    let group_count = catalog.groups.len();
    let schema_count = catalog.schemas.len();
    let _ = write!(
        html,
        r#"<div class="stats">
<div class="stat"><strong>{schema_count}</strong><span>schemas</span></div>
<div class="stat"><strong>{group_count}</strong><span>groups</span></div>
</div>
"#,
    );

    // Build group name -> schema names lookup
    let mut group_schema_names: alloc::collections::BTreeMap<&str, &[String]> =
        alloc::collections::BTreeMap::new();
    for g in &catalog.groups {
        group_schema_names.insert(&g.name, &g.schemas);
    }

    // Collect schemas assigned to groups
    let mut assigned_schemas: alloc::collections::BTreeSet<&str> =
        alloc::collections::BTreeSet::new();
    for g in &catalog.groups {
        for s in &g.schemas {
            assigned_schemas.insert(s);
        }
    }

    // Render groups
    for (group_name, group_desc) in groups_meta {
        let schema_names: Vec<&str> = group_schema_names
            .get(group_name.as_str())
            .map(|s| s.iter().map(String::as_str).collect())
            .unwrap_or_default();

        let group_schemas: Vec<&SchemaEntry> = catalog
            .schemas
            .iter()
            .filter(|s| schema_names.contains(&s.name.as_str()))
            .collect();

        if group_schemas.is_empty() {
            continue;
        }

        let _ = write!(
            html,
            r#"<details open data-group>
<summary>{}<span class="desc">— {}</span><span class="count">{} schemas</span></summary>
<div class="schema-list">
"#,
            html_escape(group_name),
            html_escape(group_desc),
            group_schemas.len(),
        );
        for schema in &group_schemas {
            write_schema_card(&mut html, schema);
        }
        html.push_str("</div>\n</details>\n");
    }

    // Remaining (unassigned) schemas
    let unassigned: Vec<&SchemaEntry> = catalog
        .schemas
        .iter()
        .filter(|s| !assigned_schemas.contains(s.name.as_str()))
        .collect();
    if !unassigned.is_empty() {
        let _ = write!(
            html,
            r#"<details data-group>
<summary>Other Schemas<span class="count">{} schemas</span></summary>
<div class="schema-list">
"#,
            unassigned.len(),
        );
        for schema in &unassigned {
            write_schema_card(&mut html, schema);
        }
        html.push_str("</div>\n</details>\n");
    }

    // Footer + script
    html.push_str(INDEX_HTML_FOOTER);
    html
}

fn write_schema_card(html: &mut String, schema: &SchemaEntry) {
    html.push_str(r#"<div class="schema-card">"#);
    let _ = write!(
        html,
        r#"<div class="schema-name"><a href="{}">{}</a></div>"#,
        html_escape(&schema.url),
        html_escape(&schema.name),
    );
    if !schema.description.is_empty() {
        let _ = write!(
            html,
            r#"<div class="schema-desc">{}</div>"#,
            html_escape(&schema.description),
        );
    }
    if !schema.file_match.is_empty() {
        html.push_str(r#"<div class="schema-patterns">"#);
        for (i, pat) in schema.file_match.iter().enumerate() {
            if i > 0 {
                html.push(' ');
            }
            let _ = write!(html, "<code>{}</code>", html_escape(pat));
        }
        html.push_str("</div>");
    }
    html.push_str("</div>\n");
}

fn html_escape(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
}

const INDEX_HTML_HEAD: &str = r#"<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Schema Catalog</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; color: #1a1a2e; background: #f8f9fa; }
.container { max-width: 960px; margin: 0 auto; padding: 2rem 1.5rem; }
header { text-align: center; margin-bottom: 2rem; padding-bottom: 1.5rem; border-bottom: 2px solid #e9ecef; }
header h1 { font-size: 2rem; font-weight: 700; color: #16213e; }
header p { color: #495057; margin-top: 0.5rem; }
.search-box { margin-bottom: 2rem; }
.search-box input { width: 100%; padding: 0.75rem 1rem; font-size: 1rem; border: 1px solid #dee2e6; border-radius: 8px; outline: none; transition: border-color 0.2s; }
.search-box input:focus { border-color: #4361ee; box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.15); }
.stats { display: flex; gap: 1.5rem; justify-content: center; margin-bottom: 2rem; flex-wrap: wrap; }
.stat { background: #fff; padding: 0.75rem 1.25rem; border-radius: 8px; border: 1px solid #e9ecef; text-align: center; }
.stat strong { display: block; font-size: 1.5rem; color: #4361ee; }
.stat span { font-size: 0.85rem; color: #6c757d; }
details { margin-bottom: 1rem; background: #fff; border-radius: 8px; border: 1px solid #e9ecef; }
summary { padding: 1rem 1.25rem; cursor: pointer; font-weight: 600; font-size: 1.1rem; color: #16213e; user-select: none; list-style: none; display: flex; align-items: center; gap: 0.5rem; }
summary::before { content: "\25B6"; font-size: 0.7rem; transition: transform 0.2s; }
details[open] > summary::before { transform: rotate(90deg); }
summary .count { font-weight: 400; font-size: 0.85rem; color: #6c757d; margin-left: auto; }
summary .desc { font-weight: 400; font-size: 0.9rem; color: #6c757d; margin-left: 0.5rem; }
.schema-list { padding: 0 1.25rem 1rem; }
.schema-card { padding: 0.75rem 0; border-top: 1px solid #f1f3f5; }
.schema-card:first-child { border-top: none; }
.schema-name { font-weight: 600; color: #16213e; }
.schema-name a { color: #4361ee; text-decoration: none; }
.schema-name a:hover { text-decoration: underline; }
.schema-desc { font-size: 0.9rem; color: #495057; margin-top: 0.25rem; }
.schema-patterns { font-size: 0.8rem; color: #868e96; margin-top: 0.25rem; }
.schema-patterns code { background: #f1f3f5; padding: 0.1rem 0.3rem; border-radius: 3px; font-size: 0.8rem; }
footer { margin-top: 3rem; padding-top: 1.5rem; border-top: 1px solid #e9ecef; text-align: center; font-size: 0.85rem; color: #868e96; }
footer a { color: #4361ee; text-decoration: none; }
.hidden { display: none; }
</style>
</head>
<body>
<div class="container">
<header>
<h1>Schema Catalog</h1>
<p>JSON Schemas for editor auto-completion, validation, and documentation</p>
</header>
<div class="search-box">
<input type="text" id="search" placeholder="Search schemas by name or description..." autocomplete="off">
</div>
"#;

const INDEX_HTML_FOOTER: &str = r#"<footer>
<p>Generated by <a href="https://github.com/lintel-rs/lintel">lintel-catalog-builder</a></p>
</footer>
</div>
<script>
document.getElementById('search').addEventListener('input', function(e) {
  var q = e.target.value.toLowerCase();
  document.querySelectorAll('.schema-card').forEach(function(card) {
    var text = card.textContent.toLowerCase();
    card.classList.toggle('hidden', q.length > 0 && !text.includes(q));
  });
  document.querySelectorAll('[data-group]').forEach(function(group) {
    var visible = group.querySelectorAll('.schema-card:not(.hidden)').length;
    group.classList.toggle('hidden', q.length > 0 && visible === 0);
    if (q.length > 0 && visible > 0) group.open = true;
  });
});
</script>
</body>
</html>
"#;

#[cfg(test)]
mod tests {
    use alloc::collections::BTreeMap;

    use schema_catalog::SchemaEntry;

    use crate::catalog::build_output_catalog;

    use super::*;

    #[tokio::test]
    async fn write_readme_generates_file() -> Result<()> {
        let dir = tempfile::tempdir()?;
        let config_path = dir.path().join("lintel-catalog.toml");
        let catalog = build_output_catalog(
            None,
            vec![
                SchemaEntry {
                    name: "A".into(),
                    description: String::new(),
                    url: String::new(),
                    source_url: None,
                    file_match: vec![],
                    versions: BTreeMap::new(),
                },
                SchemaEntry {
                    name: "B".into(),
                    description: String::new(),
                    url: String::new(),
                    source_url: None,
                    file_match: vec![],
                    versions: BTreeMap::new(),
                },
            ],
            vec![schema_catalog::CatalogGroup {
                name: "G".into(),
                description: String::new(),
                schemas: vec![],
            }],
        );
        let ctx = OutputContext {
            output_dir: dir.path(),
            config_path: &config_path,
            catalog: &catalog,
            groups_meta: &[],
            source_count: 1,
        };
        write_readme(&ctx).await?;
        let content = tokio::fs::read_to_string(dir.path().join("README.md")).await?;
        assert!(content.contains("lintel-catalog-builder"));
        assert!(content.contains("**2** schemas"));
        assert!(content.contains("**1** groups"));
        assert!(content.contains("**1** external sources"));
        Ok(())
    }
}
