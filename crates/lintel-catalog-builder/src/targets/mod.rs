mod dir;
mod github_pages;

use core::fmt::Write as _;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use schema_catalog::Catalog;
use tracing::debug;

use crate::catalog::write_catalog_json;
use crate::config::TargetConfig;

pub use self::dir::DirTarget;
pub use self::github_pages::GitHubPagesTarget;

/// Data passed to [`Target::finalize`] for writing output files.
pub struct OutputContext<'a> {
    pub output_dir: &'a Path,
    pub config_path: &'a Path,
    pub catalog: &'a Catalog,
    pub groups_meta: &'a [(String, String)],
    pub source_count: usize,
}

/// Behaviour that every output target must implement.
pub trait Target {
    /// The `base_url` configured for this target.
    fn base_url(&self) -> &str;

    /// Resolve the output directory for this target.
    fn output_dir(&self, target_name: &str, config_dir: &Path) -> PathBuf;

    /// Write all output files for this target.
    fn finalize(
        &self,
        ctx: &OutputContext<'_>,
    ) -> impl core::future::Future<Output = Result<()>> + Send;
}

/// Enum dispatch wrapper so we can store any target without `dyn`.
pub enum AnyTarget {
    Dir(DirTarget),
    GitHubPages(GitHubPagesTarget),
}

impl From<TargetConfig> for AnyTarget {
    fn from(config: TargetConfig) -> Self {
        match config {
            TargetConfig::Dir { dir, base_url } => Self::Dir(DirTarget { dir, base_url }),
            TargetConfig::GitHubPages {
                base_url,
                cname,
                dir,
            } => Self::GitHubPages(GitHubPagesTarget {
                base_url,
                cname,
                dir,
            }),
        }
    }
}

impl Target for AnyTarget {
    fn base_url(&self) -> &str {
        match self {
            Self::Dir(t) => t.base_url(),
            Self::GitHubPages(t) => t.base_url(),
        }
    }

    fn output_dir(&self, target_name: &str, config_dir: &Path) -> PathBuf {
        match self {
            Self::Dir(t) => t.output_dir(target_name, config_dir),
            Self::GitHubPages(t) => t.output_dir(target_name, config_dir),
        }
    }

    async fn finalize(&self, ctx: &OutputContext<'_>) -> Result<()> {
        match self {
            Self::Dir(t) => t.finalize(ctx).await,
            Self::GitHubPages(t) => t.finalize(ctx).await,
        }
    }
}

/// Write `catalog.json` and `README.md` — shared by all targets.
pub async fn write_common_files(ctx: &OutputContext<'_>) -> Result<()> {
    write_catalog_json(ctx.output_dir, ctx.catalog).await?;
    write_readme(ctx).await?;
    Ok(())
}

/// Generate a `README.md` in the output directory.
async fn write_readme(ctx: &OutputContext<'_>) -> Result<()> {
    let config_dir = ctx.config_path.parent().unwrap_or_else(|| Path::new("."));
    let source_repo = detect_git_remote(config_dir).await;
    let config_filename = ctx
        .config_path
        .file_name()
        .unwrap_or_default()
        .to_string_lossy();

    let schema_count = ctx.catalog.schemas.len();
    let group_count = ctx.catalog.groups.len();
    let source_count = ctx.source_count;

    let mut md = String::new();
    md.push_str("# Schema Catalog\n\n");
    md.push_str("This directory was generated by [`lintel-catalog-builder`](https://github.com/lintel-rs/lintel).\n");
    md.push_str("**Do not edit files in this directory manually** — they will be overwritten on the next run.\n\n");

    if let Some(ref repo_url) = source_repo {
        let _ = write!(md, "Source repository: <{repo_url}>\n\n");
    }

    md.push_str("## Stats\n\n");
    let _ = writeln!(md, "- **{schema_count}** schemas");
    let _ = writeln!(md, "- **{group_count}** groups");
    let _ = writeln!(md, "- **{source_count}** external sources\n");

    md.push_str("## Regenerate\n\n");
    md.push_str("```sh\n");
    let _ = writeln!(
        md,
        "lintel-catalog-builder generate --config {config_filename}"
    );
    md.push_str("```\n");

    let readme_path = ctx.output_dir.join("README.md");
    tokio::fs::write(&readme_path, md)
        .await
        .with_context(|| format!("failed to write {}", readme_path.display()))?;
    debug!(path = %readme_path.display(), "wrote README.md");
    Ok(())
}

/// Try to detect the git remote URL for a directory.
async fn detect_git_remote(dir: &Path) -> Option<String> {
    let output = tokio::process::Command::new("git")
        .args(["-C", &dir.to_string_lossy(), "remote", "get-url", "origin"])
        .output()
        .await
        .ok()?;
    if !output.status.success() {
        return None;
    }
    let url = core::str::from_utf8(&output.stdout)
        .ok()?
        .trim()
        .to_string();
    if url.is_empty() {
        return None;
    }
    Some(url)
}

#[cfg(test)]
mod tests {
    use alloc::collections::BTreeMap;

    use schema_catalog::SchemaEntry;

    use crate::catalog::build_output_catalog;

    use super::*;

    #[tokio::test]
    async fn write_readme_generates_file() -> Result<()> {
        let dir = tempfile::tempdir()?;
        let config_path = dir.path().join("lintel-catalog.toml");
        let catalog = build_output_catalog(
            None,
            vec![
                SchemaEntry {
                    name: "A".into(),
                    description: String::new(),
                    url: String::new(),
                    file_match: vec![],
                    versions: BTreeMap::new(),
                },
                SchemaEntry {
                    name: "B".into(),
                    description: String::new(),
                    url: String::new(),
                    file_match: vec![],
                    versions: BTreeMap::new(),
                },
            ],
            vec![schema_catalog::CatalogGroup {
                name: "G".into(),
                description: String::new(),
                schemas: vec![],
            }],
        );
        let ctx = OutputContext {
            output_dir: dir.path(),
            config_path: &config_path,
            catalog: &catalog,
            groups_meta: &[],
            source_count: 1,
        };
        write_readme(&ctx).await?;
        let content = tokio::fs::read_to_string(dir.path().join("README.md")).await?;
        assert!(content.contains("lintel-catalog-builder"));
        assert!(content.contains("**2** schemas"));
        assert!(content.contains("**1** groups"));
        assert!(content.contains("**1** external sources"));
        Ok(())
    }
}
